

Exceptions
==========

> Verwendung relativ vieler eigener Exception-Klassen
- Macht man das so?
Jein. Tatsächlich ist es in der Spring Welt üblich checked Exceptions (also Ausnahmen, die zwingend behandelt werden müssen , entweder in einem try-catch oder durch
eine Angabe in der Methoden - Signatur, dass die Ausnahme geworfen werden kann ( throws x) in RuntimeExceptions zu wrappen.
Das Konzept nennt sich Exception Translation und das Spring Framework selbst macht davon häufig Gebrauch. Dahinter steckt natürlioh die Vereinfachung der Implementierung, aber auch ein
weiteres Konzept: Das Fail-Fast-Prinzip.
Beim Fail-Fast-Prinzip geht es um folgendes: Wenn ein Client einer Anwendung (bsw. ein Browser) einen Request absendet, wartet er
auf die Response. Es gibt aber eine ganze Reieh von Exceptions , bei denen klar ist, dass keine gültige Antwort auf die Anfrage gesendet werden kann
(bsw. die Repräsentation eines Objektes, dass aus der Datenbank geladen wird und dann auf einer Seite visualisiert wird).
Hier erzeugt die Behandlung einer Checked Exception nur zusätzlichen Overhead, der Client muss länger warten und es wird kein Mehrwert durch die
Ausnahmebehandlung geneiert.
Auch das Wrappen von Runtimeexceptions in applikationsspezifische kann Sinn machen, wenn Fehlerfälle dadurch klarer aufgelöst werden können.
Bereits von Spring übersetzte Exceptions übersetzte Exceptions können ebefalls in manchen Situationen gewrapped werden bsw. wenn unterschiedliche
Anwendungsbestandteile die gleichen Spring Komponenten verwendet, kann in der applikationsspezifischen Exception der fachliche oder technische Kontext klarer
dargestellt werden.
Man sollte sich allerdings bewußt sein, dass gerade in Spring Boot manche Exceptions mti einem HTTP Status Code assoziiert werden, ohne dass explizit ein
Handling definiert wurde, falls man diesen Standart-Mechanismus verwenden will.
Generell gilt in Spring Boot: Für eigene Exceptions unchecked exceptions (also von RuntimeException ableiten) statt chekcked exceptions

- Kann man das anders handhaben?
- Statt zu validieren und ohne Erklärung nach "Home" zu routen doch ein 404 werfen?
404 ist der HTTP Status Code für NOT FOUND, der für BAD RQEUST ist 400. Da diese Anwendung eine web-basierte UI bereitstellt ist die Rückgabe
von 400 nicht wirklich sinnvoll, der Benutzer interagiert ja mit der Anwendung und sollte angezeigt bekommen, was er falsch gemacht hat.
HTTP Status macht in der REST Welt Sinn, weil dort der Client zurückgemeldet bekommt, dass seine Anfrage falsch formatiert war.

> Beispiel wäre Validierung von Participant beim Submit im FeedbackController
- bsp 1: ParticipantIsMissingEmailException
- bsp 2: ParticipantIsMissingMobileException

> Schreibt man die Exception-Klassen so?
Jein. Im agilen Umfeld schreibt man das was man braucht so dass es andere erweitern können, wenn sie es möchten. Wenn Du Exceptiosn schreibst,
die nur in Deiner Anwendung verwendet werden, schreibst dementsprechend auch nur die Konstruktoren, die Du wirklich verwendest.
Im Enterprise Umfeld findet man oft auch strengere Vorgabeen, was das Format der Message anbelangt, da in irgendeiner Form so etwas
wie E00347 oder ähnliches zur automatischen Auswertung von Logs gewünscht wird. Da kann es sinnvoll sein, einen Teil der Message bereits vor zu defineieren und im Konstruktor
nur noch Teilstrings zu übergeben. In REST APIS wird zudem üblicherweise eine gemeinsamne Oberklasse definiert (APIException oder ähnliches),
damit daraus eine einheitliche JSON Response für alle Schnittstellen zurückgegeben wird.
In den beiden Klaasen stört mich eigentlich nur die servialVersionId, habe noch nie gesehen, dass diese wirklich gebraucht wurde.


Filter
======

> Sollten Filter in der Art verwendet werden? Oder ist das Zweckentfremdung?
- "Nur weil es geht muss es nicht richtig sein!"
- bsp: RequestResponseProjectFilter
- Ist der Versuch validierung aus den einzelnen Controllern vorwegzunehmen
Validierung in Spring erfolgt unter der Verwendung von Springs Bean Validation Implementierung (JSR-380).
Dabei werden für die Parameter in Controller - Methoden JSR-380 Annotations (@Valid , @NotNull) etc verwendet.
Braucht man mehr Validierungslogik, kann man eigene Annotations und eigene Valieiderungsklassen definieren / implementieren.
Damit ist die Validierung komplett entkoppelt, kannst Du Dir auch in der neuen Ereigniserfassung im edit1 Berehich anschauen.




Model
=====
ViewModel:
Bitte keine Benamung von Klassen ala ContainerXY , wenn diese für das Model verwendet und dem Binden von Form und View dienen.
Das ist eine sehr EM spezifische Benamung, der Rest der Welt nennt solche Klassen BackingBean (J2EE, Srping)

> In Mongo würde man vermutlich manche Dinge zusammenfassen, oder?
- ParticipationResult und Participant zu einem

> Für JPA/MySQL gut genug geschnitten? Welche Änderung macht Sinn?

> Wird FeedbackContainer eigentlich benötigt?
- Kann ich mir den sparen, weil nur eine Map enthalten ist?
- Oder FeedbackContainer extends Map<>, damit man nicht die falsche Map an eine Methode übergeben kann?

> LoginFormContainer gleiche Frage.
- Weglassen und stattdessen einfach zwei Strings weitergeben?
- Kann man zwei String als Post-Parameter setzen oder muss das EIN Objekt sein?




Methoden und Namenskonventionen
===============================

> In Java werden boolean getter formuliert als isVarname()
- Thymeleaf fordert aber explizit getVarname(), um aus dem Template,zugreifen zu können
- Project.isPricegame() und Project.getPricegame() auf eines reduzieren oder dupliziert lassen?




ZonedDateTime
=============

> Warum sind Daten und Zeiten in Java so kacke zu handhaben?
- Siehe ZonedDateTimeHelper
- Ich glaube ich habe so etwas ähnliches in wesentlich größer schon mal gesehen ;-)
